classdef SixDOFRobot < RobotBaseClass
    properties(Access =public)   
        plyFileNameStem = 'SixDOFRobot';

        %> defaultRealQ 
        defaultRealQ  = [0,0,0,0,0,0];
    end

    methods (Access = public) 
%% Constructor 
        function self = SixDOFRobot(baseTr)
			self.CreateModel();
            if nargin == 1			
				self.model.base = self.model.base.T * baseTr;
            end            
            self.homeQ = self.RealQToModelQ(self.defaultRealQ);
            self.PlotAndColourRobot();
        end

 % %% Move to Target Position
 %    function moveToTarget(self, targetPosition)
 %        % Create a transformation matrix for the target position
 %        T_target = transl(targetPosition(1), targetPosition(2), targetPosition(3));
 % 
 %        % Calculate the inverse kinematics to find joint angles
 %        q_sol = self.model.ikine(T_target, 'mask', [1, 1, 1, 0, 0, 0]); % Mask to consider only position
 % 
 %        if isempty(q_sol)
 %            error('No solution found for the target position');
 %        else
 %            % Get the current joint angles
 %            q_current = self.model.getpos();
 % 
 %            % Define the number of steps for smooth animation
 %            numSteps = 50;
 % 
 %            % Interpolate between the current and target joint angles
 %            qMatrix = jtraj(q_current, q_sol, numSteps);
 % 
 %            % Animate the robot movement step by step
 %            for i = 1:numSteps
 %                self.model.animate(qMatrix(i, :));
 %                pause(0.05); % Pause to control the speed of the animation
 %            end
 %        end
 %    end

% %% Move to Target Position with Collision Avoidance
% function moveToTarget(self, targetPosition)
%     % Create a transformation matrix for the target position
%     T_target = transl(targetPosition(1), targetPosition(2), targetPosition(3));
% 
%     % Calculate the inverse kinematics to find joint angles
%     q_sol = self.model.ikine(T_target, 'mask', [1, 1, 1, 0, 0, 0]); % Mask to consider only position
% 
%     if isempty(q_sol)
%         error('No solution found for the target position');
%     else
%         % Get the current joint angles
%         q_current = self.model.getpos();
% 
%         % Define the number of steps for smooth animation
%         numSteps = 150;
% 
%         % Interpolate between the current and target joint angles
%         qMatrix = jtraj(q_current, q_sol, numSteps);
% 
%         % Define obstacle boundaries
%         x_min = 0.15; x_max = 0.35;
%         y_min = 0.2; y_max = 0.8;
%         z_min = 0.95; z_max = 2;
% 
%         % Check for collision and animate the robot movement
%         for i = 1:numSteps
%             % Get the transformation matrix for the current joint configuration
%             T_current = self.model.fkine(qMatrix(i, :));
% 
% 
%             % Extract position from transformation matrix
%             current_position = T_current.t;  % Use the 't' property to get translation
% 
%               % Print the end-effector position in the terminal
%             disp(['End-effector position at step ', num2str(i), ': (', ...
%                   num2str(current_position(1)), ', ', ...
%                   num2str(current_position(2)), ', ', ...
%                   num2str(current_position(3)), ')']);
% 
%             % Check if the current position is within the obstacle bounds
%             if current_position(1) >= x_min && current_position(1) <= x_max && ...
%                current_position(2) >= y_min && current_position(2) <= y_max && ...
%                current_position(3) >= z_min && current_position(3) <= z_max
%                 warning('Collision detected! Adjusting trajectory.');
%                 % Exit or handle collision avoidance (e.g., by recalculating path)
%                 return;
%             end
% 
%             % If no collision, animate the movement
%             self.model.animate(qMatrix(i, :));
%             pause(0.05); % Pause to control the speed of the animation
%         end
%     end
% end
function moveToTarget(self, targetPosition)
    % Create a transformation matrix for the target position
    T_target = transl(targetPosition(1), targetPosition(2), targetPosition(3));

    % Calculate the inverse kinematics to find joint angles
    q_sol = self.model.ikine(T_target, 'mask', [1, 1, 1, 0, 0, 0]); % Mask to consider only position

    if isempty(q_sol)
        error('No solution found for the target position');
    else
        % Get the current joint angles
        q_current = self.model.getpos();

        % Define the number of steps for smooth animation
        numSteps = 150;
        % Ensure sh
         delta2 = q_sol(1) - q_current(1);
            if abs(delta2) > pi
                if delta2 > 0
                    q_sol(1) = q_sol(1) - 2*pi;
                else
                    q_sol(1) = q_sol(1) + 2*pi;
                end
            end

        % Interpolate between the current and target joint angles
        qMatrix = jtraj(q_current, q_sol, numSteps);

        % Define obstacle boundaries
        x_min = 0.15; x_max = 0.35;
        y_min = 0.2; y_max = 0.8;
        z_min = 0.95; z_max = 2;

        % Check for collision and animate the robot movement
        for i = 1:numSteps
            % Get the transformation matrix for the current joint configuration
            T_current = self.model.fkine(qMatrix(i, :));

            % Extract position from transformation matrix
            current_position = T_current.t;

            % Check if the current position is within the obstacle bounds
            if current_position(1) >= x_min && current_position(1) <= x_max && ...
               current_position(2) >= y_min && current_position(2) <= y_max && ...
               current_position(3) >= z_min && current_position(3) <= z_max
                warning('Collision detected! Recalculating path to avoid obstacle.');
                q_now = self.model.getpos();
                % Recalculate path segments to avoid obstacle
                recalculatePath(self, q_now, T_target, numSteps, x_min, x_max, y_min, y_max, z_min, z_max);
                return; % Exit the loop after animating the segments
            end

            % If no collision, animate the movement
            self.model.animate(qMatrix(i, :));
            pause(0.05);
        end
    end
end

function recalculatePath(self, q_start, T_target, numSteps, x_min, x_max, y_min, y_max, z_min, z_max)
    % Define the intermediate waypoint
    waypoint1 = transl(1.138, -0.394, 1.1);
    waypoint2 = transl(0.729, -0.714, 1.1);
    % waypoint3 = transl(0.467, -0.749, 1.1);

    % Calculate inverse kinematics to get joint values for the waypoint
    q_waypoint1 = self.model.ikine(waypoint1, 'mask', [1, 1, 1, 0, 0, 0]);
    qMatrix_segment1 = jtraj(q_start, q_waypoint1, numSteps/2);

    q_waypoint2 = self.model.ikine(waypoint2, 'mask', [1, 1, 1, 0, 0, 0]);
    qMatrix_segment2 = jtraj(q_waypoint1, q_waypoint2, numSteps/2);

    % q_waypoint3 = self.model.ikine(waypoint3, 'mask', [1, 1, 1, 0, 0, 0]);
    % delta = q_waypoint3(1) - q_waypoint2(1);
    % if abs(delta) > pi
    %     if delta > 0
    %         q_waypoint3(1) = q_waypoint3(1) - 2*pi;
    %     else
    %         q_waypoint3(1) = q_waypoint3(1) + 2*pi;
    %     end
    % end
    % qMatrix_segment3 = jtraj(q_waypoint2, q_waypoint3, numSteps);

    q_goal = self.model.ikine(T_target, 'mask', [1, 1, 1, 0, 0, 0]);
    delta2 = q_goal(1) - q_waypoint2(1);
    if abs(delta2) > pi
        if delta2 > 0
            q_goal(1) = q_goal(1) - 2*pi;
        else
            q_goal(1) = q_goal(1) + 2*pi;
        end
    end
    qMatrix_segment4 = jtraj(q_waypoint2, q_goal, numSteps/2);

    % Animate each segment
    for j = 1:size(qMatrix_segment1, 1)
        self.model.animate(qMatrix_segment1(j, :));
        pause(0.05);
    end
    for j = 1:size(qMatrix_segment2, 1)
        self.model.animate(qMatrix_segment2(j, :));
        pause(0.05);
    end
    % for j = 1:size(qMatrix_segment3, 1)
    %     self.model.animate(qMatrix_segment3(j, :));
    %     pause(0.05);
    % end
    for j = 1:size(qMatrix_segment4, 1)
        self.model.animate(qMatrix_segment4(j, :));
        pause(0.05);
    end
end





%% CreateModel
        function CreateModel(self)       
            link(1) = Link('d', 0.3, 'a', 0, 'alpha', pi/2, 'qlim', deg2rad([-360 360]), 'offset', 0);
            link(2) = Link('d', -0.5, 'a', 0, 'alpha', 0, 'qlim', deg2rad([-360 360]), 'offset', 0); 
            link(3) = Link('d', 0, 'a', 0, 'alpha', -pi/2, 'qlim', deg2rad([-360 360]), 'offset', 0);
            link(4) = Link('d', -0.2, 'a', 0, 'alpha', 0, 'qlim', deg2rad([-360 360]), 'offset', 0);
            link(5) = Link('d', 0, 'a', 0, 'alpha', pi/2, 'qlim', deg2rad([-360 360]), 'offset', 0);
            link(6) = Link('d', -0.25, 'a', 0, 'alpha', 0, 'qlim', deg2rad([-360 360]), 'offset', 0);


            self.model = SerialLink(link,'name',self.name);

            self.model.base = transl(0.5, 0, 1);
        end   
    end
    
    methods(Hidden)
%% TestMoveJoints
        % Overriding the RobotBaseClass function, since it won't work properly
        % for this robot
        function TestMoveJoints(self)
            self.TestMoveSixDOF();
        end

%% Test Move Dobot
    function TestMoveSixDOF(self)
            qPath = jtraj(self.model.qlim(:,1)',self.model.qlim(:,2)',50);                       
            for i = 1:50              
                self.model.animate(self.RealQToModelQ(qPath(i,:)));
                pause(0.2);
            end
        end
    end
    methods(Static)
%% RealQToModelQ
        % Convert the real Q to the model Q
        function modelQ = RealQToModelQ(realQ)
            modelQ = realQ;
            modelQ(3) = Dobot.ComputeModelQ3GivenRealQ2and3( realQ(2), realQ(3) );
            modelQ(4) = pi - realQ(2) - modelQ(3);    
        end
        
%% ModelQ3GivenRealQ2and3
        % Convert the real Q2 & Q3 into the model Q3
        function modelQ3 = ComputeModelQ3GivenRealQ2and3(realQ2,realQ3)
            modelQ3 = pi/2 - realQ2 + realQ3;
        end
        
%% ModelQToRealQ
        % Convert the model Q to the real Q
        function realQ = ModelQToRealQ( modelQ )
            realQ = modelQ;
            realQ(3) = Dobot.ComputeRealQ3GivenModelQ2and3( modelQ(2), modelQ(3) );
        end
        
%% RealQ3GivenModelQ2and3
        % Convert the model Q2 & Q3 into the real Q3
        function realQ3 = ComputeRealQ3GivenModelQ2and3( modelQ2, modelQ3 )
            realQ3 = modelQ3 - pi/2 + modelQ2;
        end
    end
end
